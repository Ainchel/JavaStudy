package ch01.sec04;
//실수 데이터 타입 정리.

//실수 데이터 타입은 2종류 있으며, 메모리 할당량 및 유효 소수 자리수는 아래와 같다.
//1) float : 4byte(32bit), 소수 7자리까지.
//2) double : 8byte(64bit), 소수 15자리까지.

//자바에서 실수 타입 데이터는 부동소수점 방식으로 메모리를 잡는다. (공간에 부호 + 가수 + 지수부로 포함)
//1) float의 경우, 부호 1bit, 지수 8bit, 가수 23bit로 구성.
//2) double의 경우, 부호 1bit, 지수 11bit, 가수 52bit로 구성.

//실수 타입의 데이터 구조 상, 가수 부분 데이터에 값을 전부 담지 못할 경우, 값을 근사값 처리하여 정밀도가 손실될 수 있다.

//실수의 리터럴은 10진수(소수) 및 e/E를 포함한 거듭제곱을 끼고 표현이 가능하다.

//실수 리터럴은 기본적으로 double 타입으로 해석해서, float 타입의 경우 f를 붙여 컴파일러에 인식시켜줘야 한다.

public class floatdoublePractice 
{
	public static void main(String[] args) 
	{
		//아래는 실수 리터럴의 작성 예제.
		double x = 0.25; // 10진수로 작성
		double y = -3.14; // 10진수로 작성
		
		double xx = 5e2; // e의 거듭제곱을 포함한 작성 => 5 * 10의 제곱 = 500;
		double yy = 0.12E-2; // e의 마이너스 거듭제곱을 포함한 작성 -> 0.12 * 0.1의 제곱 = 0.0012	
	
		//아래는 float 타입에 f를 붙여 인식시키는 예제.
		float f1 = 3.14f;
		float f2 = 3e6f;
		//float f3 = 314e-2; 해당 문구는 f를 붙이지 않아, double로 인식되어 타입이 안맞는다는 에러가 발생한다.
		
		//아래는 float타입과 double타입의 유효소수점 표시 예제.
		float ff1 = 0.1234567890123456789f;
		double dd1 = 0.1234567890123456789;
		
		System.out.println("ff1 : " + ff1);
		//0.12345679 출력.
		//소수 7번째 자리까지 정확하며, 8번째 자리가 근사값으로 출력
		System.out.println("dd1 : " + dd1);
		//0.12345678901234568 출력.
		//소수 16번째 자리까지 정확하며, 17번째 자리가 근사값으로 출력
	}
	

}
